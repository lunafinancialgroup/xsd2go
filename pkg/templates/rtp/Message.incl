type {{ .GoName }} struct {
	XMLName                 xml.Name                                     `xml:"Message"`
	Xmlns                   []xml.Attr                                   `xml:",attr"`
    {{- if .ContainsText }}
        Value {{ .GoTypeName }} `xml:",chardata"`
    {{- end }}
    {{- range .Attributes }}
        {{ .GoName }} {{ .GoForeignModule }}{{ .GoType }} `xml:"{{ .XmlName }},{{ if eq .MinOccurs "0" }},omitempty{{ end }}"`
    {{- end }}
    {{- range .Elements }}
        {{ .GoFieldName }} {{ if .Array }}[]{{ end }}{{ if eq .MinOccurs "0" }}*{{ end }}{{ .GoForeignModule }}{{ .GoTypeName }} `xml:"{{ .TargetNamespace }} {{ .XmlName }}{{ if eq .MinOccurs "0" }},omitempty{{ end }}"`
    {{- end }}
}

// UnmarshalXML is a custom unmarshaller that allows us to capture the xmlns attributes
func (v *{{ .GoName }}) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if (attr.Name.Space == "" && attr.Name.Local == "xmlns") || (attr.Name.Space == "xmlns") {
			newAttr := xml.Attr{}
			newAttr.Value = attr.Value
			newAttr.Name = xml.Name{}
			if attr.Name.Space == "" {
				newAttr.Name.Local = attr.Name.Local
			} else {
				newAttr.Name.Local = fmt.Sprintf("%s:%s", attr.Name.Space, attr.Name.Local)
			}
			v.Xmlns = append(v.Xmlns, newAttr)
		}
	}

	// Go on with unmarshalling.
	type vv {{ .GoName }}
	return d.DecodeElement((*vv)(v), &start)
}
